\chapter{Reti di Calcolatori}

Le \textbf{reti di calcolatori} sono sistemi che permettono a dispositivi interconnessi di scambiare dati e condividere risorse. Sono la base di quasi ogni infrastruttura informatica moderna, dal World Wide Web alle reti aziendali locali.

\section{Modello di Comunicazione Client/Server}
Il \textbf{modello Client/Server} è un'architettura di rete distribuita in cui i client (richiedenti servizi) e i server (fornitori di servizi) sono entità separate che comunicano su una rete. È il modello dominante per la maggior parte delle applicazioni web e molte applicazioni enterprise.

\subsection{Funzionamento del Modello Client/Server}
\begin{itemize}
    \item \textbf{Client}: Invia richieste di servizi al server, riceve le risposte e le presenta all'utente. Tipicamente è l'applicazione utente (es. browser web, app mobile).
    \item \textbf{Server}: Ascolta le richieste dei client, le elabora (es. recupera dati, esegue calcoli), e invia le risposte al client. Gestisce le risorse condivise (database, file, stampanti).
    \item \textbf{Comunicazione}: Avviene tramite protocolli di rete (es. TCP/IP) su porte specifiche. Il client avvia la connessione e la richiesta.
\end{itemize}

\subsection{Vantaggi e Svantaggi del Modello Client/Server}
\begin{itemize}
    \item \textbf{Vantaggi}:
    \begin{itemize}
        \item \textbf{Centralizzazione}: Gestione centralizzata di dati e risorse, facilitando la sicurezza e la manutenzione.
        \item \textbf{Scalabilità}: Possibilità di scalare il server per gestire più richieste o aggiungere più client alla rete.
        \item \textbf{Sicurezza}: Controllo più agevole degli accessi e dei permessi sui dati centralizzati.
        \item \textbf{Manutenzione Facilitata}: Aggiornamenti e backup possono essere eseguiti sul server senza influenzare i client.
    \end{itemize}
    \item \textbf{Svantaggi}:
    \begin{itemize}
        \item \textbf{Single Point of Failure (Punto Singolo di Fallimento)}: Se il server si blocca, tutti i client perdono l'accesso ai servizi.
        \item \textbf{Collo di Bottiglia del Server}: Un server sovraccarico può rallentare l'intera rete.
        \item \textbf{Costo}: I server e la loro manutenzione possono essere costosi.
    \end{itemize}
\end{itemize}

\section{Protocollo HTTP}
L'\textbf{Hypertext Transfer Protocol (HTTP)} è il protocollo applicativo fondamentale per il World Wide Web. Opera nel modello client/server ed è stateless.

\subsection{Funzionamento e Applicazione in HTTP}
\begin{itemize}
    \item Un \textbf{client} (tipicamente un browser web) invia una \textbf{richiesta HTTP} (es. GET, POST, PUT, DELETE) a un \textbf{server web}. La richiesta include URL, metodo, header e, opzionalmente, un body.
    \item Il \textbf{server} riceve la richiesta, la elabora (es. recupera una pagina web, esegue uno script), e invia una \textbf{risposta HTTP}. La risposta include uno stato (es. 200 OK, 404 Not Found), header e il body (es. il contenuto HTML della pagina richiesta).
    \item La comunicazione avviene tipicamente su TCP/IP (porta 80 per HTTP, 443 per HTTPS).
\end{itemize}
\textbf{Esempio}: Quando un utente digita un URL nel browser, il browser è il client che invia una richiesta HTTP al server. Il server risponde con la pagina HTML e le risorse associate, che il browser poi renderizza.

\subsection{Connessioni Stateless e Stateful}

\subsubsection{Stateless Connection (Connessione Senza Stato)}
\begin{itemize}
    \item \textbf{Definizione}: Ogni richiesta inviata dal client al server è completamente indipendente e autocontenuta. Il server non mantiene alcuna informazione (stato) sulle richieste precedenti del client. Ogni richiesta include tutte le informazioni necessarie per essere elaborata.
    \item \textbf{Vantaggi}: Scalabilità elevata (il server non deve allocare memoria per lo stato di ogni client), resilienza (se un server si blocca, un altro può prendere il suo posto senza perdere lo stato), semplicità di progettazione lato server.
    \item \textbf{Svantaggi}: Richiede che ogni richiesta contenga potenzialmente informazioni ridondanti (es. credenziali di autenticazione), e può essere meno efficiente per operazioni che richiedono una sequenza di passaggi.
    \item \textbf{HTTP come Stateless}: HTTP è intrinsecamente stateless. Ogni richiesta HTTP è trattata come se fosse la prima e unica richiesta tra il client e il server.

\end{itemize}

\subsubsection{Stateful Connection (Connessione Con Stato)}
\begin{itemize}
    \item \textbf{Definizione}: Il server mantiene e ricorda lo stato delle interazioni passate con un client per un certo periodo di tempo. Le richieste successive possono fare riferimento a questo stato.
    \textbf{Vantaggi}: Minore ridondanza di informazioni nelle richieste successive, può semplificare la logica client per sequenze di operazioni complesse.
    \item \textbf{Svantaggi}: Minore scalabilità (il server deve mantenere lo stato per ogni client attivo, consumando risorse), minore resilienza (se il server che detiene lo stato si blocca, la sessione del client viene persa), complessità maggiore.
    \item \textbf{Esempi}: Una connessione TCP (a un livello più basso) è stateful; una sessione di login a un database.
\end{itemize}

\subsection{Metodi per Gestire la Persistenza dello Stato in HTTP}
Dato che HTTP è stateless, per costruire applicazioni web interattive che richiedono il mantenimento dello stato (es. carrelli della spesa, sessioni utente), sono stati sviluppati diversi meccanismi:
\begin{itemize}
    \item \textbf{Cookies}: Piccoli frammenti di dati che il server invia al browser del client e che il browser memorizza. Ad ogni richiesta successiva verso lo stesso server, il browser invia nuovamente i cookie al server. Usati per ID di sessione, preferenze utente, tracciamento.
    \item \textbf{Session IDs (ID di Sessione)}: Il server crea un ID univoco per ogni sessione utente e lo invia al client (spesso tramite cookie). Il server memorizza i dati della sessione sul proprio lato (nel database o in memoria cache) associati a quell'ID. Usati per mantenere lo stato di login, carrelli della spesa.
    \item \textbf{URL Rewriting (Parametri URL)}: Lo stato viene incorporato direttamente nell'URL come parametri. Usato quando i cookie non sono disponibili.
    \item \textbf{Hidden Form Fields}: Dati nascosti all'interno di moduli HTML che vengono inviati con ogni richiesta POST. Usati per mantenere lo stato tra le pagine di un modulo multi-step.
    \item \textbf{Web Storage (Local Storage, Session Storage)}: API JavaScript che permettono alle applicazioni web di memorizzare dati nel browser del client (Local Storage persistente, Session Storage per la durata della sessione del browser). Usati per memorizzare dati client-side, cache di dati.
\end{itemize}

\section{Standard ISO/OSI}
Il \textbf{modello ISO/OSI (Open Systems Interconnection)} è un modello concettuale che descrive come i sistemi di comunicazione in una rete interagiscono e cooperano. È diviso in sette strati (layer), ciascuno con responsabilità specifiche, che operano sopra lo strato precedente e forniscono servizi a quello successivo.

\subsection{Struttura a Sette Strati del Modello OSI}
\begin{enumerate}
    \item \textbf{Strato Fisico (Physical Layer)}: Gestisce la trasmissione e ricezione di flussi di bit non strutturati e grezzi su un mezzo fisico. Definisce le specifiche elettriche, meccaniche, procedurali e funzionali. (Es. cavi Ethernet, Wi-Fi, connettori).
    \item \textbf{Strato di Collegamento Dati (Data Link Layer)}: Fornisce la trasmissione di dati da nodo a nodo, rilevando e correggendo potenzialmente gli errori che possono verificarsi a livello fisico. Gestisce l'indirizzamento MAC e il controllo del flusso. (Es. Ethernet, PPP).
    \item \textbf{Strato di Rete (Network Layer)}: Gestisce l'instradamento dei pacchetti attraverso la rete (routing). È responsabile dell'indirizzamento logico (IP) e della selezione del percorso migliore. (Es. IP, ICMP).
    \item \textbf{Strato di Trasporto (Transport Layer)}: Fornisce la comunicazione end-to-end tra processi su host diversi. Assicura la consegna affidabile dei dati, il controllo di flusso e il controllo della congestione. (Es. TCP, UDP).
    \item \textbf{Strato di Sessione (Session Layer)}: Stabilisce, gestisce e termina le sessioni di comunicazione tra applicazioni. Gestisce la sincronizzazione e il dialogo.
    \item \textbf{Strato di Presentazione (Presentation Layer)}: Si occupa della sintassi e della semantica dei dati scambiati. Traduce i dati tra il formato dell'applicazione e il formato di rete, e gestisce la crittografia/decrittografia e la compressione.
    \item \textbf{Strato di Applicazione (Application Layer)}: Fornisce servizi di rete direttamente alle applicazioni dell'utente finale. (Es. HTTP, FTP, SMTP, DNS).
\end{enumerate}

\section{Livello di Trasporto (TCP vs UDP)}
Il \textbf{Livello di Trasporto} è il quarto strato del modello OSI e fornisce servizi di comunicazione end-to-end tra applicazioni in esecuzione su host diversi. I due protocolli principali a questo livello sono TCP e UDP.

\subsection{TCP (Transmission Control Protocol)}
\textbf{TCP} è un protocollo orientato alla connessione, affidabile e con controllo di flusso e congestione.
\begin{itemize}
    \item \textbf{Orientato alla Connessione}: Stabilisce una connessione (handshake a tre vie) prima di iniziare la trasmissione dei dati e la termina esplicitamente.
    \item \textbf{Affidabile}: Garantisce la consegna dei dati, senza perdite o duplicazioni, e nell'ordine corretto.
    \begin{itemize}
        \item \textbf{Numerazione e Riconoscimenti (ACK)}: Ogni segmento inviato è numerato e il mittente si aspetta un riconoscimento (ACK) dal destinatario. Se un ACK non arriva entro un certo tempo, il segmento viene ritrasmesso.
        \item \textbf{Checksum}: Utilizza un checksum per rilevare errori nei dati.
    \end{itemize}
    \item \textbf{Controllo di Flusso}: Impedisce a un mittente veloce di sovraccaricare un destinatario lento. Il destinatario comunica al mittente quanto spazio buffer è disponibile (finestra di ricezione).
    \item \textbf{Controllo di Congestione}: Evita che un mittente invii troppi dati in una rete congestionata, riducendo la velocità di trasmissione se rileva congestione (es. tramite perdite di pacchetti o ritardi).
    \item \textbf{Segmentazione e Riasssemblaggio}: Spezza i dati dell'applicazione in segmenti più piccoli per la trasmissione e li riassembla alla destinazione.
    \item \textbf{Applicazioni Tipiche}: Web Browse (HTTP), trasferimento file (FTP), email (SMTP), connessioni sicure (SSH).
\end{itemize}

\subsection{UDP (User Datagram Protocol)}
\textbf{UDP} è un protocollo senza connessione, inaffidabile e che non implementa controllo di flusso o congestione.
\begin{itemize}
    \item \textbf{Senza Connessione}: Non stabilisce una connessione preliminare. Ogni datagramma viene inviato indipendentemente.
    \item \textbf{Inaffidabile (Best-Effort)}: Non garantisce la consegna dei dati, l'ordine di arrivo, né che non ci siano duplicazioni. Non ci sono ACK né ritrasmissioni automatiche.
    \item \textbf{Nessun Controllo di Flusso/Congestione}: Trasmette i dati alla massima velocità possibile senza preoccuparsi della capacità del destinatario o della rete.
    \item \textbf{Overhead Minimo}: Ha un header molto piccolo, il che lo rende molto efficiente in termini di overhead.
    \item \textbf{Applicazioni Tipiche}: Streaming multimediale (audio/video), VoIP, DNS, giochi online, dove la velocità è più importante dell'affidabilità perfetta (piccole perdite possono essere accettabili).
\end{itemize}

\section{Subnetting (Suddivisione di Sottoreti)}
Il \textbf{subnetting} è il processo di divisione di una singola rete IP (Internet Protocol) più grande in sottoreti (subnets) più piccole e gestibili. Questa pratica è fondamentale per migliorare l'efficienza della rete, la sicurezza e la gestione degli indirizzi IP. Ogni sottorete è una rete IP indipendente e logicamente separata.

\subsection{Obiettivi del Subnetting}
\begin{itemize}
    \item \textbf{Efficienza nell'uso degli indirizzi IP}: Invece di allocare un'intera classe di indirizzi a una singola organizzazione, il subnetting permette di suddividere lo spazio IP, utilizzando gli indirizzi in modo più parsimonioso.
    \item \textbf{Riduzione del traffico di rete}: Il traffico di broadcast è confinato alla propria sottorete, riducendo il carico sui router e migliorando le prestazioni complessive della rete.
    \item \textbf{Miglioramento della Sicurezza}: È più facile implementare politiche di sicurezza e isolare segmenti della rete.
    \item \textbf{Facilitazione della Gestione della Rete}: Le reti più piccole sono più facili da gestire, diagnosticare e risolvere i problemi.
\end{itemize}

\subsection{Indirizzi IP e Maschere di Sottorete}
Un indirizzo IP (IPv4) è un numero a 32 bit, diviso in quattro ottetti (separati da punti). È composto da due parti:
\begin{itemize}
    \item \textbf{Indirizzo di Rete (Network Address)}: Identifica la rete o sottorete a cui appartiene un dispositivo. Tutti i dispositivi sulla stessa sottorete hanno lo stesso indirizzo di rete.
    \item \textbf{Indirizzo Host (Host Address)}: Identifica un dispositivo specifico all'interno di quella rete o sottorete.
\end{itemize}
La \textbf{maschera di sottorete (subnet mask)} è un numero a 32 bit che aiuta a distinguere la parte di rete dalla parte host di un indirizzo IP. È composta da una serie di `1` (bit di rete) seguiti da una serie di `0` (bit di host).

\subsubsection{Notazione CIDR (Classless Inter-Domain Routing)}
La notazione \textbf{CIDR} è un modo conciso per rappresentare indirizzi IP e subnet mask. Consiste nell'indirizzo IP seguito da uno slash (`/`) e un numero intero che indica il numero di bit che compongono l'indirizzo di rete (la lunghezza della maschera di sottorete).
\begin{itemize}
    \item \textbf{Esempio}: `192.168.1.0/24` indica che i primi 24 bit sono dedicati alla rete, e i rimanenti 8 bit agli host.
    \item Il numero dopo lo slash è la \textbf{lunghezza del prefisso di rete}.
\end{itemize}

\subsection{Calcolo del Subnetting (Esempio Pratico)}
Consideriamo una rete di Classe C (es. `192.168.1.0/24`) e vogliamo suddividerla per ospitare diverse sottoreti per dipartimenti diversi, ognuno con un numero specifico di host.

\textbf{Scenario}: Una rete `192.168.1.0/24` deve essere divisa in 4 sottoreti per ospitare almeno 50 host per sottorete.

\textbf{Passo 1: Determinare il numero di bit necessari per le sottoreti.}
Abbiamo bisogno di 4 sottoreti. Il numero di bit ($n$) necessari per creare $S$ sottoreti è dato da $2^n \ge S$.
$2^n \ge 4 \Rightarrow n=2$ bit.

\textbf{Passo 2: Determinare il numero di bit per gli host.}
La maschera originale è /24, quindi abbiamo 8 bit dedicati agli host ($32 - 24 = 8$).
Usando 2 bit per le sottoreti, rimangono $8 - 2 = 6$ bit per gli host in ogni sottorete.
Il numero massimo di host per sottorete sarà $2^H - 2$, dove $H$ è il numero di bit per gli host.
$2^6 - 2 = 64 - 2 = 62$ host. Questo soddisfa il requisito di almeno 50 host per sottorete.

\textbf{Passo 3: Calcolare la nuova maschera di sottorete.}
La nuova maschera avrà i bit di rete originali (24) più i bit presi in prestito per le sottoreti (2).
Nuova lunghezza prefisso = $24 + 2 = 26$.
La nuova maschera di sottorete sarà `/26`.
In forma decimale: `255.255.255.192` (perché i 2 bit accesi nell'ultimo ottetto sono $128 + 64 = 192$).

\textbf{Passo 4: Elencare le sottoreti valide.}
Le sottoreti iniziano a intervalli del "blocco size" determinato dal numero di bit presi in prestito. La dimensione del blocco per l'ultimo ottetto è $256 - 192 = 64$.
\begin{itemize}
    \item \textbf{Sottorete 1}:
    \begin{itemize}
        \item Indirizzo di Rete: `192.168.1.0/26`
        \item Primo Indirizzo Host Valido: `192.168.1.1`
        \item Ultimo Indirizzo Host Valido: `192.168.1.62`
        \item Indirizzo di Broadcast: `192.168.1.63`
    \end{itemize}
    \item \textbf{Sottorete 2}:
    \begin{itemize}
        \item Indirizzo di Rete: `192.168.1.64/26`
        \item Primo Indirizzo Host Valido: `192.168.1.65`
        \item Ultimo Indirizzo Host Valido: `192.168.1.126`
        \item Indirizzo di Broadcast: `192.168.1.127`
    \end{itemize}
    \item \textbf{Sottorete 3}:
    \begin{itemize}
        \item Indirizzo di Rete: `192.168.1.128/26`
        \item Primo Indirizzo Host Valido: `192.168.1.129`
        \item Ultimo Indirizzo Host Valido: `192.168.1.190`
        \item Indirizzo di Broadcast: `192.168.1.191`
    \end{itemize}
    \item \textbf{Sottorete 4}:
    \begin{itemize}
        \item Indirizzo di Rete: `192.168.1.192/26`
        \item Primo Indirizzo Host Valido: `192.168.1.193`
        \item Ultimo Indirizzo Host Valido: `192.168.1.254`
        \item Indirizzo di Broadcast: `192.168.1.255`
    \end{itemize}
\end{itemize}
Questo esempio mostra come una singola rete può essere efficientemente suddivisa per soddisfare esigenze specifiche di un'organizzazione.